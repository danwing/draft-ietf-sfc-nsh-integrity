<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-sfc-nsh-integrity-latest"
     ipr="trust200902">
  <front>
    <title abbrev="Integrity Protection for the NSH">Integrity Protection for
    the Network Service Header (NSH) and Encryption of Sensitive Context
    Headers</title>

    <author fullname="Mohamed Boucadair" initials="M." surname="Boucadair">
      <organization>Orange</organization>

      <address>
        <postal>
          <street></street>

          <city>Rennes</city>

          <code>35000</code>

          <country>France</country>
        </postal>

        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>

    <author fullname="Tirumaleswar Reddy" initials="T." surname="Reddy">
      <organization abbrev="McAfee">McAfee, Inc.</organization>

      <address>
        <postal>
          <street>Embassy Golf Link Business Park</street>

          <city>Bangalore</city>

          <region>Karnataka</region>

          <code>560071</code>

          <country>India</country>
        </postal>

        <email>TirumaleswarReddy_Konda@McAfee.com</email>
      </address>
    </author>

    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Citrix">Citrix Systems, Inc.</organization>

      <address>
        <postal>
          <street></street>

          <country>USA</country>
        </postal>

        <email>dwing-ietf@fuggles.com</email>
      </address>
    </author>

    <date />

    <workgroup>SFC</workgroup>

    <keyword>Security</keyword>

    <keyword>Resilience</keyword>

    <keyword>Automation</keyword>

    <keyword>Service delivery</keyword>

    <keyword>Providers</keyword>

    <keyword>Differentiated services</keyword>

    <keyword>TE</keyword>

    <keyword>Traffic Engineering</keyword>

    <keyword>Attack mitigation</keyword>

    <abstract>
      <t>This specification adds integrity protection and optional encryption
      of sensitive metadata directly to the Network Service Header (NSH) used
      for Service Function Chaining (SFC).</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Many advanced Service Functions (SFs) are enabled for the delivery of
      value-added services. Typically, SFs are used to meet various service
      objectives such as IP address sharing, avoiding covert channels,
      detecting Denial-of-Service (DoS) attacks and protecting network
      infrastructures against them, network slicing, etc. Because of the
      proliferation of such advanced SFs together with complex service
      deployment constraints that demand more agile service delivery
      procedures, operators need to rationalize their service delivery logics
      and master their complexity while optimising service activation time
      cycles. The overall problem space is described in <xref
      target="RFC7498"></xref>.</t>

      <t><xref target="RFC7665"></xref> presents a data plane architecture
      addressing the problematic aspects of existing service deployments,
      including topological dependence and configuration complexity. It also
      describes an architecture for the specification, creation, and
      maintenance of Service Function Chains (SFCs) within a network. That is,
      how to define an ordered set of SFs and ordering constraints that must
      be applied to packets/flows selected as a result of traffic
      classification. <xref target="RFC8300"></xref> specifies the SFC
      encapsulation: Network Service Header (NSH).</t>

      <t>The NSH data is unauthenticated and unencrypted <xref
      target="RFC8300"></xref>, forcing a service topology that requires
      security and privacy to use a transport encapsulation that supports such
      features. Note that some transport encapsulation (e.g., IPsec) only
      provide hop-by-hop security between two SFC data plane elements (e.g.,
      two Service Function Forwarders (SFFs), SFF to SF) and do not provide
      SF-to-SF security of NSH metadata. For example, if IPsec is used, SFFs
      or SFs within a Service Function Path (SFP) not authorized to access the
      privacy-sensitive metadata will have access to the metadata. As a
      reminder, the metadata referred to is an information that is inserted by
      Classifiers or intermediate SFs and shared with downstream SFs; such
      information is not visible to the communication endpoints (Section 4.9
      of <xref target="RFC7665"></xref>).</t>

      <t>The lack of such capability was reported during the development of
      <xref target="RFC8300"></xref> and <xref target="RFC8459"></xref>. The
      reader may refer to Section 3.2.1 of <xref
      target="I-D.arkko-farrell-arch-model-t"></xref> for a discussion on the
      need for more awareness about attacks from within closed domains.</t>

      <t>This specification fills that gap. Concretely, this document adds
      integrity protection and optional encryption of sensitive metadata
      directly to the NSH (<xref target="overview"></xref>); integrity
      protects the packet payload and provides replay protection (<xref
      target="time"></xref>). Thus, the NSH does not have to rely upon an
      underlying transport encapsulation for security and confidentiality.</t>

      <t>This specification introduces new Variable-Length Context Headers to
      carry fields necessary for integrity protected NSH headers and encrypted
      Context Headers (<xref target="new"></xref>), and is therefore only
      applicable to NSH MD Type 0x02 (Section 2.5 of <xref
      target="RFC8300"></xref>). MTU considerations are discussed in <xref
      target="MTU"></xref>.</t>

      <t>This specification limits thus access to an information within an SFP
      to entities that have a need to interpret it.</t>
    </section>

    <section anchor="notation" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"></xref><xref target="RFC8174"></xref> when, and
      only when, they appear in all capitals, as shown here.</t>

      <t>This document makes use of the terms defined in <xref
      target="RFC7665"></xref> and <xref target="RFC8300"></xref>.</t>

      <t>The document defines the following terms:<list style="symbols">
          <t>SFC data plane element: Refers to NSH-aware SF, SFF, SFC Proxy,
          or Classifier as defined in the SFC data plane architecture <xref
          target="RFC7665"></xref> and further refined in <xref
          target="RFC8300"></xref>.</t>

          <t>SFC control element: A logical entity that instructs one or more
          SFC data plane elements on how to process NSH packets within an
          SFC-enabled domain.</t>

          <t>Key Identifier: A key identifier used to identify and deliver
          keys to authorized entities. See for example, 'kid' usage in <xref
          target="RFC7635"></xref>.</t>

          <t>NSH data: The NSH is composed of a Base Header, a Service Path
          Header, and optional Context Headers. NSH data refers to all the
          above headers and the packet or frame on which the NSH is imposed to
          realize an SFP.</t>

          <t>NSH imposer: Refers to an SFC data plane element that is entitled
          to impose the NSH with the Context Headers defined in this
          document.</t>
        </list></t>
    </section>

    <section anchor="req" title="Assumptions and Basic Requirements">
      <t>Section 2 of <xref target="RFC8300"></xref> specifies that the NSH
      data can be spread over three headers:<list style="symbols">
          <t>Base Header: Provides information about the service header and
          the payload protocol.</t>

          <t>Service Path Header: Provides path identification and location
          within an SFP.</t>

          <t>Context Header(s): Carries metadata (i.e., context data) along a
          service path.</t>
        </list></t>

      <t>The NSH allows to share context information (a.k.a., metadata) with
      downstream NSH-aware data elements on a per SFC/SFP basis. To that
      aim:<list style="empty">
          <t>The control plane is used to instruct the Classifier about the
          set of context information to be supplied for a given service
          function chain.</t>

          <t>The control plane is also used to instruct an NSH-aware SF about
          any metadata it needs to attach to packets for a given service
          function chain. This instruction may occur any time during the
          validity lifetime of an SFC/SFP. The control plane may indicate, for
          a given service function chain, an order for consuming a set of
          contexts supplied in a packet.</t>

          <t>An NSH-aware SF can also be instructed about the behavior it
          should adopt after consuming a context information that was supplied
          in the NSH. For example, the context can be maintained, updated, or
          stripped.</t>

          <t>An SFC Proxy may be instructed about the behavior it should adopt
          to process the context information that was supplied in the NSH on
          behalf of an NSH-unaware SF (e.g., the context can be maintained or
          stripped). The SFC Proxy may also be instructed to add some new
          context information into the NSH on behalf of an NSH-unaware SF.</t>
        </list></t>

      <t>In reference to <xref target="op"></xref>, <list style="symbols">
          <t>Classifiers, NSH-aware SFs, and SFC proxies are entitled to
          update the Context Header(s).</t>

          <t>Only NSH-aware SFs and SFC proxies are entitled to update the
          Service Path Header.</t>

          <t>SFFs are entitled to modify the Base Path header (TTL value, for
          example). Nevertheless, SFFs are not supposed to act on the Context
          Headers or look into the content of the Context Headers.</t>
        </list></t>

      <t>Thus, the following requirements:<list style="symbols">
          <t>Only Classifiers, NSH-aware SFs, and SFC proxies MUST be able to
          encrypt and decrypt a given Context Header.</t>

          <t>Both encrypted and unencrypted Context Headers MAY be included in
          the same NSH. That is, some Context Headers (TLVs) may be protected
          while others do not.</t>

          <t>The solution MUST provide integrity protection for the Service
          Path Header.</t>

          <t>The solution MAY provide integrity protection for the Base
          Header. The implications of disabling such checks are discussed in
          <xref target="mac1"></xref>.</t>
        </list></t>

      <t><figure align="center" anchor="op" title="Summary of NSH Actions">
          <artwork align="center"><![CDATA[+----------------+-----------------------------+-------------------+
|                | Insert, remove, or replace  |  Update the NSH   |
|                |          the NSH            |                   |
|                |                             |                   |
| SFC Data Plane +---------+---------+---------+---------+---------+
|   Element      |         |         |         |Decrement| Update  |
|                | Insert  | Remove  | Replace | Service | Context |
|                |         |         |         |  Index  |Header(s)|
+================+=========+=========+=========+=========+=========+
|                |    +    |         |    +    |         |    +    |
|   Classifier   |         |         |         |         |         |
+----------------+---------+---------+---------+---------+---------+
|Service Function|         |    +    |         |         |         | 
|Forwarder (SFF) |         |         |         |         |         |
+----------------+---------+---------+---------+---------+---------+
|Service Function|         |         |         |    +    |    +    |
|      (SF)      |         |         |         |         |         |
+----------------+---------+---------+---------+---------+---------+
|                |    +    |    +    |         |    +    |    +    |
|   SFC Proxy    |         |         |         |         |         |
+----------------+---------+---------+---------+---------+---------+]]></artwork>
        </figure></t>

      <t></t>
    </section>

    <section anchor="overview" title="Design Overview">
      <t></t>

      <section title="Supported Security Services">
        <t>This specification provides the functions described in the
        following subsections.</t>

        <section title="Encrypt All or a Subset of Context Headers">
          <t>The solution allows to encrypt all or a subset of NSH Context
          Headers by Classifiers, NSH-aware SFs, and SFC proxies.</t>

          <t>As depicted in <xref target="eroles"></xref>, SFFs are not
          involved in data encryption. This document enforces this design
          approach by encrypting Context Headers with keys that are not
          supplied to SFFs, thus enforcing this limitation by protocol (rather
          than requirements language).</t>

          <texttable align="center" anchor="eroles"
                     title="Encryption Function Supported by SFC Data Plane Elements">
            <ttcol>Data Plane Element</ttcol>

            <ttcol>Base and Service Headers Encryption</ttcol>

            <ttcol>Metadata Encryption</ttcol>

            <c>Classifier</c>

            <c>No</c>

            <c>Yes</c>

            <c>SFF</c>

            <c>No</c>

            <c>No</c>

            <c>NSH-aware SF</c>

            <c>No</c>

            <c>Yes</c>

            <c>SFC Proxy</c>

            <c>No</c>

            <c>Yes</c>

            <c>NSH-unaware SF</c>

            <c>No</c>

            <c>No</c>
          </texttable>

          <t>The SFC control plane is assumed to instruct the Classifier(s),
          NSH-aware SFs, and SFC proxies with the set of Context Headers
          (privacy-sensitive metadata, typically) that must be encrypted.
          Encryption keying material is only provided to these SFC data
          elements.</t>

          <t>The control plane may also indicate the set of SFC data plane
          elements that are entitled to supply a given Context Header (e.g.,
          in reference to their identifiers as assigned within the SFC-enabled
          domain). It is out of the scope of this document to elaborate on how
          such instructions are provided to the appropriate SFC data plane
          elements, nor to detail the structure used to store the
          instructions.</t>

          <t>The Service Path Header (Section 2 of <xref
          target="RFC8300"></xref>) is not encrypted because SFFs use Service
          Index (SI) in conjunction with Service Path Identifier (SPI) for
          determining the next SF in the path.</t>
        </section>

        <section title="Integrity Protection">
          <t>The solution provides integrity protection for the NSH data. Two
          levels of assurance (LoAs) are supported.</t>

          <t>A first level of assurance where all NSH data except the Base
          Header are integrity protected (<xref target="first"></xref>). In
          this case, the NSH imposer may be a Classifier, an NSH-aware SF, or
          an SFC Proxy. SFFs are not thus provided with authentication
          material. Further details are discussed in <xref
          target="enc1"></xref>.<figure align="center" anchor="first"
              title="First Level of Assurance">
              <artwork><![CDATA[   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
   |                Transport Encapsulation                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
   |                Base Header                            |  |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  N
|  |                Service Path Header                    |  S
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  H
|  |                Context Header(s)                      |  |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
|  |                Original Packet                        |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                          
+------Scope of integrity protected data                                                
]]></artwork>
            </figure></t>

          <t>A second level of assurance where all NSH data, including the
          Base Header, are integrity protected (<xref target="sec"></xref>).
          In this case, the NSH imposer may be a Classifier, an NSH-aware SF,
          an SFF, or an SFC Proxy. Further details are provided in <xref
          target="enc2"></xref>.</t>

          <t><figure align="center" anchor="sec"
              title="Second Level of Assurance">
              <artwork><![CDATA[   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
   |                Transport Encapsulation                |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
|  |                Base Header                            |  |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  N
|  |                Service Path Header                    |  S
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  H
|  |                Context Header(s)                      |  |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
|  |                Original Packet                        |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                           
+----Scope of integrity protected data 
                                              
]]></artwork>
            </figure></t>

          <t>The integrity protection scope is explicitly signaled to
          NSH-aware SFs and SFC proxies in the NSH by means of a dedicated MD
          Type (<xref target="new"></xref>).</t>

          <t>In both levels of assurance, the unencrypted Context Headers and
          the packet on which the NSH is imposed are subject to integrity
          protection.</t>

          <t><xref target="iroles"></xref> lists the roles of SFC data plane
          elements in providing integrity protection for the NSH.</t>

          <texttable align="center" anchor="iroles"
                     title="Integrity Protection Supported by SFC Data Plane Elements">
            <ttcol>Data Plane Element</ttcol>

            <ttcol>Integrity Protection</ttcol>

            <c>Classifier</c>

            <c>Yes</c>

            <c>SFF</c>

            <c>No (first LoA); Yes (second LoA)</c>

            <c>NSH-aware SF</c>

            <c>Yes</c>

            <c>SFC Proxy</c>

            <c>Yes</c>

            <c>NSH-unaware SF</c>

            <c>No</c>
          </texttable>
        </section>
      </section>

      <section title="One Secret Key, Two Security Services">
        <t>The authenticated encryption algorithm defined in <xref
        target="RFC7518"></xref> is used to provide NSH data integrity and to
        encrypt the Context Headers that carry privacy-sensitive metadata.</t>

        <t>The authenticated encryption algorithm provides a unified
        encryption and authentication operation which turns plaintext into
        authenticated ciphertext and vice versa. The generation of secondary
        keys MAC_KEY and ENC_KEY from the secret key (K) is discussed in
        Section 5.2.2.1 of <xref target="RFC7518"></xref>: <list
            style="symbols">
            <t>The ENC_KEY is used for encrypting the Context Headers and the
            message integrity of the NSH data is calculated using the
            MAC_KEY.</t>

            <t>If the Context Headers are not encrypted, the Hashed Message
            Authentication Mode (HMAC) algorithm discussed in <xref
            target="RFC4868"></xref> is used to integrity protect the NSH
            data.</t>
          </list></t>

        <t>The advantage of using the authenticated encryption algorithm is
        that NSH-aware SFs and SFC proxies only need to re-compute the message
        integrity of the NSH data after decrementing the Service Index (SI)
        and do not have to re-compute the ciphertext. The other advantage is
        that SFFs do not have access to the ENC_KEY and cannot act on the
        encrypted Context Headers and, only in case of the second level of
        assurance, SFFs do have access to the MAC_KEY. Similarly, an NSH-aware
        SF or SFC Proxy not allowed to decrypt the Context Headers will not
        have access to the ENC_KEY.</t>

        <t>The authenticated encryption algorithm or HMAC algorithm to be used
        by SFC data plane elements is typically controlled using the SFC
        control plane. Mandatory to implement authenticated encryption and
        HMAC algorithms are listed in <xref target="mti"></xref>.</t>

        <t>The authenticated encryption process takes as input four octet
        strings: a secret key (K), a plaintext (P), Additional Authenticated
        Data (A) (which contains the data to be authenticated, but not
        encrypted), and an Initialization Vector (IV). The ciphertext value
        (E) and the Authentication Tag value (T) are provided as outputs.</t>

        <t>In order to decrypt and verify, the cipher takes as input K, IV, A,
        T, and E. The output is either the plaintext or an error indicating
        that the decryption failed as described in Section 5.2.2.2 of <xref
        target="RFC7518"></xref>.</t>
      </section>

      <section anchor="mti"
               title="Mandatory-to-Implement Authenticated Encryption and HMAC Algorithms">
        <t>Classifiers, NSH-aware SFs, and SFC proxies MUST implement the
        AES_128_CBC_HMAC_SHA_256 algorithm and SHOULD implement the
        AES_192_CBC_HMAC_SHA_384 and AES_256_CBC_HMAC_SHA_512 algorithms.</t>

        <t>Classifiers, NSH-aware SFs, and SFC proxies MUST implement the
        HMAC-SHA-256-128 algorithm and SHOULD implement the HMAC-SHA-384-192
        and HMAC-SHA-512-256 algorithms.</t>

        <t>SFFs MAY implement the aforementioned cipher suites and HMAC
        algorithms.</t>

        <t><list style="symbols">
            <t>Note: The use of AES-GCM + HMAC may have CPU and packet size
            implications (need for a second 128-bit authentication tag).</t>
          </list></t>
      </section>

      <section title="Key Management">
        <t>The procedure for the allocation/provisioning of secret keys (K)
        and authenticated encryption algorithm or MAC_KEY and HMAC algorithm
        is outside the scope of this specification. As such, this
        specification does not mandate the support of any specific
        mechanism.</t>

        <t>The documents does not assume nor preclude the following:<list
            style="symbols">
            <t>The same keying material is used for all the service functions
            used within an SFC-enabled domain.</t>

            <t>Distinct keying material is used per SFP by all involved SFC
            data path elements.</t>

            <t>Per-tenant keys are used.</t>
          </list></t>

        <t>In order to accommodate deployments relying upon keying material
        per SFC/SFP and also the need to update keys after encrypting NSH data
        for certain amount of time, this document uses key identifier (kid) to
        unambiguously identify the appropriate keying material. Doing so
        allows to address the problem of synchronization of keying
        material.</t>

        <t>Additional information on manual vs. automated key management and
        when one should be used over the other can be found in <xref
        target="RFC4107"></xref>.</t>
      </section>

      <section title="New NSH Variable-Length Context Headers">
        <t>New NSH Variable-Length Context Headers are defined in <xref
        target="new"></xref> for NSH data integrity protection and,
        optionally, encryption of Context Headers carrying privacy-sensitive
        metadata. Concretely, an NSH imposer includes (1) the key identifier
        to identify the keying material, (2) the timestamp to protect against
        replay attacks (<xref target="time"></xref>), and (3) the Message
        Authentication Code (MAC) for the target NSH data (depending on the
        integrity protection scope) calculated using the MAC_KEY and
        optionally Context Headers encrypted using ENC_KEY.</t>

        <t>An SFC data plane element that needs to check the integrity of the
        NSH data uses MAC_KEY and the HMAC algorithm for the key identifier
        being carried in the NSH.</t>

        <t>An NSH-aware SF or SFC Proxy that needs to decrypt some Context
        Headers uses ENC_Key and the decryption algorithm for the key
        identifier being carried in the NSH.</t>

        <t><xref target="prorules"></xref> specifies the detailed
        procedure.</t>
      </section>

      <section title="Encapsulation of NSH within NSH">
        <t>As discussed in <xref target="RFC8459"></xref>, an SFC-enabled
        domain (called, upper-level domain) may be decomposed into many
        sub-domains (called, lower-level domains). In order to avoid
        maintaining state to restore back upper-lower NSH information at the
        boundaries of lower-level domains, two NSH levels are used: an
        Upper-NSH which is imposed at the boundaries of the upper-level domain
        and a Lower-NSH that is pushed by the Classifier of a lower-level
        domain in front of the original NSH (<xref target="nest"></xref>). As
        such, the Upper-NSH information is carried along the lower-level chain
        without modification. The packet is forwarded in the top-level domain
        according to the Upper-NSH, while it is forwarded according to the
        Lower-NSH in a lower-level domain.</t>

        <t><figure align="center" anchor="nest"
            title="Encapsulation of NSH within NSH">
            <artwork><![CDATA[                    +---------------------------------+
                    |     Transport Encapsulation     |
                 +->+---------------------------------+
                 |  |        Lower-NSH Header         |
                 |  +---------------------------------+
                 |  |        Upper-NSH Header         |
                 |  +---------------------------------+
                 |  |          Original Packet        |
                 +->+---------------------------------+
                 |
                 |                                          
                 +----Scope of NSH security protection 
                      provided by a lower-level domain                                           
]]></artwork>
          </figure></t>

        <t>SFC data plane elements of a lower-level domain includes the
        Upper-NSH when computing the MAC.</t>

        <t>Keying material used at the upper-level domain SHOULD NOT be the
        same as the one used by a lower-level domain.</t>
      </section>
    </section>

    <section anchor="new" title="New NSH Variable-Length Context Headers">
      <t>This section specifies the format of new Variable-Length Context
      headers that are used for NSH integrity protection and, optionally,
      Context Headers encryption.</t>

      <t>In particular, this section defines two "MAC and Encrypted Metadata"
      Context Headers; each having specific deployment constraints. Unlike
      <xref target="enc1"></xref>, the level of assurance provided in <xref
      target="enc2"></xref> requires sharing MAC_KEY with SFFs. Both Context
      headers have the same format as shown in <xref target="new"></xref>.</t>

      <t><figure align="center" anchor="mac"
          title="MAC and Encrypted Metadata Context Header">
          <artwork><![CDATA[        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Metadata Class       |      Type     |U|    Length   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Key Length  |         Key Identifier (Variable)               ~ 
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
       ~                      Timestamp (8 bytes)                      ~ 
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
       | IV Length     |     Initialization Vector  (Variable)         ~
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               |
       |     Message Authentication Code and optional Encrypted        |
       ~                     Context Headers                           ~
       |                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
        </figure></t>

      <section anchor="enc1" title="MAC#1 Context Header">
        <t>MAC#1 Context Header is a variable-length TLV that carries the
        Message Authentication Code (MAC) for the Service Path Header, Context
        Headers, and the inner packet on which NSH is imposed, calculated
        using MAC_KEY and optionally Context Headers encrypted using ENC_KEY.
        The scope of the integrity protection provided by this TLV is depicted
        in <xref target="scope1"></xref>.</t>

        <t>This MAC scheme does not require sharing MAC_KEY with SFFs. It does
        not require to re-compute the MAC by each SFF because of TTL
        processing. <xref target="mac1"></xref> discusses the possible threat
        associated with this level of assurance.</t>

        <figure align="center" anchor="scope1" title="Scope of MAC#1">
          <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |    
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--+
   |          Service Path Identifier              | Service Index |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |                                                               |   |
   ~       Variable-Length Unencrypted Context Headers  (opt.)     ~   |
   |                                                               |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |          Metadata Class       |      Type     |U|    Length   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   | Key Length  |              Key Identifier                     ~   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   ~                      Timestamp (8 bytes)                      ~   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   | IV Length   |           Initialization Vector                 ~   |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
|  ~             Context Header TLVs to encrypt (opt.)             ~   |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   | 
|  |                                                               |   |
|  ~               Inner Packet on which NSH is imposed            ~   |
|  |                                                               |   |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--|
|                                                                      |
|                                                                      |
|                                                                      | 
|                                       Integrity Protection Scope ----+
+----Encrypted Data                                                
]]></artwork>
        </figure>

        <t></t>

        <t>In reference to <xref target="mac"></xref>, the description of the
        fields is as follows:<list style="symbols">
            <t>Metadata Class: MUST be set to 0x0 (Section 2.5.1 of <xref
            target="RFC8300"></xref>).</t>

            <t>Type: TBD1 (See <xref target="IANA"></xref>)</t>

            <t>U: Unassigned bit (Section 2.5.1 of <xref
            target="RFC8300"></xref>).</t>

            <t>Length: Variable.</t>

            <t>Key Length: Variable. Carries the length of the key
            identifier.</t>

            <t>Key Identifier: Carries a variable length Key Identifier object
            used to identify and deliver keys to SFC data plane elements. This
            identifier is helpful to accommodate deployments relying upon
            keying material per SFC/SFP. The key identifier helps in resolving
            the problem of synchronization of keying material.</t>

            <t>Timestamp: Carries an unsigned 64-bit integer value that is
            expressed in seconds relative to 1970-01-01T00:00Z in UTC time.
            See <xref target="timef"></xref> for more details.</t>

            <t>IV Length: Carries the length of the IV (Section 5.2 of <xref
            target="RFC7518"></xref>). If encryption is not used, IV length is
            set to zero.</t>

            <t>Initialization Vector: Carries the IV for authenticated
            encryption algorithm as discussed in Section 5.2 of <xref
            target="RFC7518"></xref>.</t>

            <t>The Additional Authenticated Data (defined in <xref
            target="RFC7518"></xref>) MUST be the Service Path header, the
            unencrypted Context headers, and the inner packet on which the NSH
            is imposed .</t>

            <t>Message Authentication Code covering the entire NSH data
            excluding the Base header.</t>
          </list></t>
      </section>

      <section anchor="enc2" title="MAC#2 Context Header">
        <t>MAC#2 Context Header is a variable-length TLV that carries the MAC
        for the entire NSH data calculated using MAC_KEY and optionally
        Context Headers encrypted using ENC_KEY. The scope of the integrity
        protection provided by this TLV is depicted in <xref
        target="scope2"></xref>.</t>

        <figure align="center" anchor="scope2" title="Scope of MAC#2">
          <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--+
   |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |          Service Path Identifier              | Service Index |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |                                                               |   |
   ~       Variable-Length Unencrypted Context Headers  (opt.)     ~   |
   |                                                               |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |          Metadata Class       |      Type     |U|    Length   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   | Key Length  |              Key Identifier                     ~   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   ~                      Timestamp (8 bytes)                      ~   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   | IV Length   |           Initialization Vector                 |   |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
|  ~             Context Header TLVs to encrypt (opt.)             ~   |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   | 
|  |                                                               |   |
|  ~               Inner Packet on which NSH is imposed            ~   |
|  |                                                               |   |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--|
|                                                                      |
|                                                                      |
|                                                                      | 
|                                       Integrity Protection Scope ----+
+----Encrypted Data                     
]]></artwork>
        </figure>

        <t></t>

        <t>In reference to <xref target="mac"></xref>, the description of the
        fields is as follows:<list style="symbols">
            <t>Metadata Class: MUST be set to 0x0 (Section 2.5.1 of <xref
            target="RFC8300"></xref>).</t>

            <t>Type: TBD2 (See <xref target="IANA"></xref>)</t>

            <t>U: Unassigned bit (Section 2.5.1 of <xref
            target="RFC8300"></xref>).</t>

            <t>Length: Variable.</t>

            <t>Key Length: See <xref target="enc1"></xref>.</t>

            <t>Key Identifier: See <xref target="enc1"></xref>.</t>

            <t>Timestamp: See <xref target="timef"></xref>.</t>

            <t>IV Length: See <xref target="enc1"></xref>.</t>

            <t>Initialization Vector: See <xref target="enc1"></xref>.</t>

            <t>The Additional Authenticated Data (defined in <xref
            target="RFC7518"></xref>) MUST be the entire NSH data (i.e.,
            including the Base Header) excluding the Context Headers to be
            encrypted.</t>

            <t>Message Authentication Code covering the entire NSH data and
            optional encrypted Context Headers.</t>
          </list></t>
      </section>
    </section>

    <section anchor="timef" title="Timestamp Format">
      <t>This section follows the template provided in Section 3 of <xref
      target="RFC8877"></xref>.</t>

      <t>The format of the Timestamp field introduced in <xref
      target="new"></xref> is depicted in <xref target="tf"></xref>.</t>

      <t><figure anchor="tf" title="Timestamp Field Format">
          <artwork><![CDATA[        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                            Seconds                            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           Fraction                            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
        </figure>Timestamp field format:<list style="empty">
          <t>Seconds: specifies the integer portion of the number of seconds
          since the epoch.</t>

          <t>+ Size: 32 bits.</t>

          <t>+ Units: seconds.</t>

          <t>Fraction: specifies the fractional portion of the number of
          seconds since the epoch.</t>

          <t>+ Size: 32 bits.</t>

          <t>+ Units: the unit is 2^(-32) seconds, which is roughly equal to
          233 picoseconds.</t>
        </list></t>

      <t>Epoch:<list style="empty">
          <t>The epoch is 1970-01-01T00:00Z in UTC time.</t>
        </list></t>

      <t>Leap seconds:<list style="empty">
          <t>This timestamp format is affected by leap seconds. The timestamp
          represents the number of seconds elapsed since the epoch minus the
          number of leap seconds.</t>
        </list></t>

      <t>Resolution:<list style="empty">
          <t>The resolution is 2^(-32) seconds.</t>
        </list></t>

      <t>Wraparound:<list style="empty">
          <t>This time format wraps around every 2^32 seconds, which is
          roughly 136 years. The next wraparound will occur in the year
          2106.</t>
        </list>Synchronization aspects:<list style="empty">
          <t>It is assumed that SFC data plane elements are synchronized to
          UTC using a synchronization mechanism that is outside the scope of
          this document. In typical deployments SFC data plane elements use
          NTP <xref target="RFC5905"></xref> for synchronization. Thus, the
          timestamp may be derived from the NTP-synchronized clock, allowing
          the timestamp to be measured with respect to the clock of an NTP
          server. Since the NTP time format is affected by leap seconds, the
          current timestamp format is similarly affected. Therefore, the value
          of a timestamp during or slightly after a leap second may be
          temporarily inaccurate.</t>
        </list></t>
    </section>

    <section anchor="prorules" title="Processing Rules">
      <t>The following subsections describe the processing rules for integrity
      protected NSH and optionally encrypted Context Headers.</t>

      <section anchor="gen" title="Generic Behavior">
        <t>This document adheres to the recommendations in <xref
        target="RFC8300"></xref> for handling the Context Headers at both
        ingress and egress SFC boundary nodes (i.e., to strip the entire NSH,
        including Context Headers).</t>

        <t>Failures of a classifier to inject the Context Headers defined in
        this document SHOULD be logged locally while a notification alarm MAY
        be sent to an SFC control element. Failures of an NSH-aware node to
        validate the integrity of the NSH data MUST cause that packet to be
        discarded while a notification alarm MAY be sent to an SFC control
        element. The details of sending notification alarms (i.e., the
        parameters affecting the transmission of the notification alarms
        depend on the information in the context header such as frequency,
        thresholds, and content in the alarm) SHOULD be configurable by the
        SFC control plane.</t>

        <t>NSH-aware SFs and SFC proxies MAY be instructed to strip some
        encrypted Context Headers from the packet or to pass the data to the
        next SF in the service function chain after processing the content of
        the Context Headers. If no instruction is provided, the default
        behavior for intermediary NSH-aware nodes is to maintain such Context
        Headers so that the information can be passed to next NSH-aware hops.
        NSH-aware SFs and SFC proxies MUST re-apply the integrity protection
        if any modification is made to the Context Headers (strip a Context
        Header, update the content of an existing Context Header, insert a new
        Context Header).</t>

        <t>An NSH-aware SF or SFC Proxy that is not allowed to decrypt any
        Context Headers MUST NOT be given access to the ENC_KEY.</t>

        <t>Otherwise, an NSH-aware SF or SFC Proxy that receives encrypted
        Context Headers, for which it is not allowed to consume a specific
        Context Header it decrypts (but consumes others), MUST keep that
        Context Header unaltered when forwarding the packet upstream.</t>

        <t>Only one instance of "MAC and Encrypted Metadata" Context Header
        (<xref target="new"></xref>) is allowed. If multiple instances of "MAC
        and Encrypted Metadata" Context Header are included in an NSH packet,
        the SFC data element MUST process the first instance and ignore
        subsequent instances, and MAY log or increase a counter for this event
        as per Section 2.5.1 of <xref target="RFC8300"></xref>.</t>

        <t>MTU and fragmentation considerations are discussed in <xref
        target="MTU"></xref>.</t>
      </section>

      <section title="MAC NSH Data Generation">
        <t>If the Context Headers are not encrypted, the HMAC algorithm
        discussed in <xref target="RFC4868"></xref> is used to integrity
        protect the target NSH data. An NSH imposer inserts a "MAC and
        Encrypted Metadata" Context Header for integrity protection (<xref
        target="new"></xref>).</t>

        <t>The NSH imposer computes the message integrity for the target NSH
        data (depending on the integrity protection scope discussed in <xref
        target="new"></xref>) using MAC_KEY and HMAC algorithm. It inserts the
        MAC in the "MAC and Encrypted Metadata" Context Header. The length of
        the MAC is decided by the HMAC algorithm adopted for the particular
        key identifier.</t>

        <t>The Message Authentication Code (T) computation process can be
        illustrated as follows:</t>

        <figure>
          <artwork><![CDATA[      T = HMAC-SHA-256-128(MAC_KEY, A)
]]></artwork>
        </figure>

        <t></t>

        <t>An entity in the SFP that intends to update the NSH MUST follow the
        above behavior to maintain message integrity of the NSH for subsequent
        validations.</t>
      </section>

      <section title="Encrypted NSH Metadata Generation">
        <t>An NSH imposer can encrypt Context Headers carrying
        privacy-sensitive metadata, i.e., encrypted and unencrypted metadata
        may be carried simultaneously in the same NSH packet (<xref
        target="up"></xref>).</t>

        <figure align="center" anchor="up"
                title="NSH with Encrypted and Unencrypted Metadata">
          <artwork><![CDATA[      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Service Path Identifier              | Service Index |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
     |                                                               |
     ~       Variable-Length Unencrypted Context Headers  (opt.)     ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     ~                      Key Identifier                           ~
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     ~                      Timestamp                                ~
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     ~                   MAC and Encrypted Context Headers           ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
        </figure>

        <t>In an SFC-enabled domain where pervasive monitoring <xref
        target="RFC7258"></xref> is possible, all Context Headers carrying
        privacy-sensitive metadata MUST be encrypted; doing so,
        privacy-sensitive metadata is not revealed to attackers. Privacy
        specific threats are discussed in Section 5.2 of <xref
        target="RFC6973"></xref>.</t>

        <t>Using K and authenticated encryption algorithm, the NSH imposer
        encrypts the Context Headers (as set by the control plane <xref
        target="req"></xref>), computes the message integrity for the target
        NSH data, and inserts the resulting payload in the "MAC and Encrypted
        Metadata" Context Header (<xref target="new"></xref>). The entire TLV
        carrying a privacy-sensitive metadata is encrypted (that is, including
        the MD Class, Type, Length, and associated metadata of each Context
        Header).</t>

        <t>The message Authentication Tag (T) and ciphertext (E) computation
        process can be illustrated as follows:</t>

        <figure>
          <artwork><![CDATA[      MAC_KEY = initial MAC_KEY_LEN octets of K,
      ENC_KEY = final ENC_KEY_LEN octets of K,
      E = CBC-PKCS7-ENC(ENC_KEY, P),
      M = MAC(MAC_KEY, A || IV || E || AL),
      T = initial T_LEN octets of M. 
      MAC and Encrypted Metadata = E || T  
]]></artwork>
        </figure>

        <t></t>

        <t>As specified in <xref target="RFC7518"></xref>, the octet string
        (AL) is equal to the number of bits in the Additional Authenticated
        Data (A) expressed as a 64-bit unsigned big-endian integer.</t>

        <t>An authorized entity in the SFP that intends to update the content
        of an encrypted Context Header or needs to add a new encrypted Context
        Header MUST also follow the aforementioned behavior.</t>

        <t>An SFF or NSH-aware SF or SFC Proxy that only has access to the
        MAC_KEY, but not the ENC_KEY, computes the message Authentication Tag
        (T) after decrementing the TTL (by the SFF) or SI (by an SF or SFC
        Proxy) and replaces the Authentication Tag in the NSH with the
        computed Authentication Tag. Similarly, an NSH-aware SF (or SFC Proxy)
        that does not modify the encrypted Context headers also follows the
        aforementioned behavior.</t>

        <t>The message Authentication Tag (T) computation process can be
        illustrated as follows:</t>

        <t><figure>
            <artwork><![CDATA[      M = MAC(MAC_KEY, A || IV || E || AL), 
      T = initial T_LEN octets of M. 
]]></artwork>
          </figure></t>
      </section>

      <section anchor="time" title="Timestamp for Replay Attack">
        <t>The Timestamp imposed by an initial Classifier is left untouched
        along an SFP. However, it can be updated when reclassification occurs
        (Section 4.8 of <xref target="RFC7665"></xref>). The same
        considerations for setting the Timestamp are followed in both initial
        classification and reclassification (<xref target="timef"></xref>).
        </t>

        <t>The received NSH is accepted by an NSH-aware node if the Timestamp
        (TS) in the NSH is recent enough to the reception time of the NSH
        (TSrt). The following formula is used for this check:</t>

        <t><figure>
            <artwork><![CDATA[          -Delta < (TSrt - TS) < +Delta
]]></artwork>
          </figure></t>

        <t>The Delta interval is a configurable parameter. The RECOMMENDED
        value for the allowed Delta is 2 seconds. If the timestamp is not
        within the boundaries, then the SFC data plane element receiving such
        packet MUST discard the NSH message.</t>

        <t>Replay attacks are still possible within the Delta interval, but
        that is an acceptable risk. Lowering the Delta interval may soften
        this risk, but special care should be taken when setting very low
        values as this may lead to dropping legitimate traffic. <list
            style="empty">
            <t>Note 1: Replay attacks within the Delta interval may be
            detected by an NSH-aware node by recording a unique value derived,
            for example, from the NSH data and Original packet (e.g., using
            SHA2). Such NSH-aware node will reject duplicates when the count
            of a given derived value exceeds a particular threshold. The SF
            has to maintain the unique values only for the time of Delta
            interval seconds. The complexity of such approach is to be
            weighted against other methods (e.g., set a lower acceptable Delta
            value) and actual risks specific to each deployment. </t>

            <t>Note 2: Early version of this specification used a sequence
            number to detect replay attacks, but that design was abandoned
            because a given SF instance may not receive all packets of a given
            service function chain for various reasons (e.g., load-balancing,
            SFC offloads). </t>
          </list></t>

        <t>All SFC data plane elements must be synchronized among themselves.
        These elements may be synchronized to a global reference time.</t>
      </section>

      <section title="NSH Data Validation">
        <t>When an SFC data plane element receives an NSH packet, it MUST
        first ensure that a "MAC and Encrypted Metadata" Context Header is
        included. It MUST silently discard the message if the timestamp is
        invalid (<xref target="time"></xref>). It MUST log an error at least
        once per the SPI for which the "MAC and Encrypted Metadata" Context
        Header is missing.</t>

        <t>If the timestamp check is successfully passed, the SFC data plane
        element proceeds then with NSH data integrity validation. The SFC data
        plane element computes the message integrity for the target NSH data
        (depending on the integrity protection scope discussed in <xref
        target="new"></xref>) using the MAC_KEY and HMAC algorithm for the key
        identifier. If the value of the newly generated digest is identical to
        the one enclosed in the NSH, the SFC data plane element is certain
        that the NSH data has not been tampered and validation is therefore
        successful. Otherwise, the NSH packet MUST be discarded.</t>
      </section>

      <section title="Decryption of NSH Metadata">
        <t>If entitled to consume a supplied encrypted Context Header, an
        NSH-aware SF or SFC Proxy decrypts metadata using (K) and decryption
        algorithm for the key identifier in the NSH.</t>

        <t>Authenticated encryption algorithm has only a single output, either
        a plaintext or a special symbol (FAIL) that indicates that the inputs
        are not authentic (Section 5.2.2.2 of <xref
        target="RFC7518"></xref>).</t>
      </section>
    </section>

    <section anchor="MTU" title="MTU Considerations">
      <t>The SFC architecture prescribes that additional information be added
      to packets to: <list style="symbols">
          <t>Identify SFPs: this is typically the NSH Base Header and Service
          Path Header.</t>

          <t>Carry metadata such those defined in Section <xref
          format="default" target="new"></xref>.</t>

          <t>Steer the traffic along the SFPs: transport encapsulation.</t>
        </list></t>

      <t>This added information increases the size of the packet to be carried
      along an SFP.</t>

      <t>Aligned with Section 5 of <xref target="RFC8300"></xref>, it is
      RECOMMENDED for network operators to increase the underlying MTU so that
      NSH traffic is forwarded within an SFC-enabled domain without
      fragmentation. The available underlying MTU should be taken into account
      by network operators when providing SFs with the required Context
      Headers to be injected per SFP and the size of the data to be carried in
      these Context Headers.</t>

      <t>If the underlying MTU cannot be increased to accommodate the NSH
      overhead, network operators may rely upon a transport encapsulation
      protocol with the required fragmentation handling. The impact of
      activating such feature on SFFs should be carefully assessed by network
      operators (Section 5.6 of <xref target="RFC7665"></xref>).</t>

      <t>When dealing with MTU issues, network operators should consider the
      limitations of various transport encapsulations such as those discussed
      in <xref target="I-D.ietf-intarea-tunnels"></xref>.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Data plane SFC-related security considerations, including privacy,
      are discussed in Section 6 of <xref target="RFC7665"></xref> and Section
      8 of <xref target="RFC8300"></xref>. In particular, Section 8.2.2 of
      <xref target="RFC8300"></xref> states that attached metadata (i.e.,
      Context Headers) should be limited to that necessary for correct
      operation of the SFP. Also, that section indicates that <xref
      target="RFC8165"></xref> discusses metadata considerations that
      operators can take into account when using NSH. </t>

      <t>The guidelines for cryptographic key management are discussed in
      <xref target="RFC4107"></xref>.</t>

      <t>The interaction between the SFC data plane elements and a key
      management system MUST NOT be transmitted in clear since this would
      completely destroy the security benefits of the integrity protection
      solution defined in this document. The secret key (K) must have an
      expiration time assigned as the latest point in time before which the
      key may be used for integrity protection of NSH data and encryption of
      Context Headers. Prior to the expiration of the secret key, all
      participating NSH-aware nodes SHOULD have the control plane distribute a
      new key identifier and associated keying material so that when the
      secret key is expired, those nodes are prepared with the new secret key.
      This allows the NSH imposer to switch to the new key identifier as soon
      as necessary. It is RECOMMENDED that the next key identifier and
      associated keying material be distributed by the control plane well
      prior to the secret key expiration time.</t>

      <t>NSH data are exposed to several threats:</t>

      <t><list style="symbols">
          <t>A man-in-the-middle attacker modifying the NSH data.</t>

          <t>Attacker spoofing the NSH data.</t>

          <t>Attacker capturing and replaying the NSH data.</t>

          <t>Data carried in Context Headers revealing privacy-sensitive
          information to attackers.</t>

          <t>Attacker replacing the packet on which the NSH is imposed with a
          bogus packet.</t>
        </list></t>

      <t>In an SFC-enabled domain where the above attacks are possible, (1)
      NSH data MUST be integrity-protected and replay-protected, and (2)
      privacy-sensitive NSH metadata MUST be encrypted for confidentiality
      preservation purposes. The Base and Service Path headers are not
      encrypted.</t>

      <t>MACs with two levels of assurance are defined in <xref
      target="new"></xref>. Considerations specific to each level of assurance
      are discussed in Sections <xref format="counter" target="mac1"></xref>
      and <xref format="counter" target="mac2"></xref>.</t>

      <t>The attacks discussed in <xref
      target="I-D.nguyen-sfc-security-architecture"></xref> are handled owing
      to the solution specified in this document, except for attacks dropping
      packets. Such attacks can be detected relying upon statistical analysis;
      such analysis is out of scope of this document. Also, if SFFs are not
      involved in the integrity checks, a misbehaving SFF which decrements SI
      while this should be done by an SF (SF bypass attack) will be detected
      by an upstream SF because the integrity check will fail.</t>

      <t>Some events are logged locally with notification alerts sent by
      NSH-aware nodes to a Control Element. These events SHOULD be rate
      limited.</t>

      <t>The solution specified in this document does not provide data origin
      authentication.</t>

      <t>In order to detect compromised nodes, it is assumed that appropriate
      mechanisms to monitor and audit an SFC-enabled domain to detect
      misbehavior and to deter misuse are in place. Compromised nodes can thus
      be withdrawn from active service function chains using appropriate
      control plane mechanisms. </t>

      <section anchor="mac1" title="MAC#1">
        <t>An active attacker can potentially modify the Base header (e.g.,
        decrement the TTL so the next SFF in the SFP discards the NSH packet).
        In the meantime, an active attacker can also drop NSH packets. As
        such, this attack is not considered an attack against the security
        mechanism specified in the document.</t>

        <t>No device other than the NSH-aware SFs in the SFC-enabled domain
        should be able to update the integrity protected NSH data. Similarly,
        no device other than the NSH-aware SFs and SFC proxies in the
        SFC-enabled domain should be able to decrypt and update the Context
        Headers carrying privacy-sensitive metadata. In other words, if the
        NSH-aware SFs and SFC proxies in the SFC-enabled domain are considered
        fully trusted to act on the NSH data, only these elements can have
        access to privacy-sensitive NSH metadata and the keying material used
        to integrity protect NSH data and encrypt Context Headers.</t>
      </section>

      <section anchor="mac2" title="MAC#2">
        <t>SFFs can detect whether an illegitimate node has altered the
        content of the Base header. Such messages must be discarded with
        appropriate logs and alarms generated (see <xref
        target="gen"></xref>).</t>
      </section>

      <section title="Time Synchronization">
        <t>Section 5.6 of <xref target="RFC8633"></xref> describes best
        current practices to be considered in deployments where SFC data plane
        elements use NTP for time synchronization purposes. </t>

        <t>Also, a mechanism to provide cryptographic security for NTP is
        specified in <xref target="RFC8915"></xref>.</t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document requests IANA to assign the following types from the
      "NSH IETF-Assigned Optional Variable-Length Metadata Types" (0x0000 IETF
      Base NSH MD Class) registry available at:
      https://www.iana.org/assignments/nsh/nsh.xhtml#optional-variable-length-metadata-types.</t>

      <t><figure>
          <artwork><![CDATA[+-------+-------------------------------+----------------+
| Value | Description                   | Reference      |
+=======+===============================+================+
| TBD1  | MAC and Encrypted Metadata #1 | [ThisDocument] |
| TBD2  | MAC and Encrypted Metadata #2 | [ThisDocument] |
+-------+-------------------------------+----------------+]]></artwork>
        </figure></t>
    </section>

    <section title="Acknowledgements">
      <t>This document was edited as a follow up to the discussion in
      IETF#104:
      https://datatracker.ietf.org/meeting/104/materials/slides-104-sfc-sfc-chair-slides-01
      (slide 7).</t>

      <t>Thanks to Joel Halpern, Christian Jacquenet, Dirk von Hugo, Tal
      Mizrahi, Daniel Migault, and Diego Lopez for the comments.</t>

      <t>Many thanks to Steve Hanna for the secdir review. </t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.8300"?>

      <?rfc include='reference.RFC.7665'?>

      <?rfc include='reference.RFC.2119'?>

      <?rfc include='reference.RFC.8174'?>

      <?rfc include='reference.RFC.4868'?>

      <?rfc include='reference.RFC.7518'?>

      <?rfc include='reference.RFC.4107'?>

      <?rfc include='reference.RFC.8877'?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.8459"?>

      <?rfc include='reference.RFC.7498'?>

      <?rfc include='reference.RFC.5905'?>

      <?rfc include="reference.RFC.7258"?>

      <?rfc include="reference.RFC.6973"?>

      <?rfc include='reference.RFC.8165'?>

      <?rfc include='reference.I-D.ietf-intarea-tunnels'?>

      <?rfc include='reference.I-D.arkko-farrell-arch-model-t'?>

      <?rfc include='reference.I-D.nguyen-sfc-security-architecture'?>

      <?rfc include='reference.RFC.7635'?>

      <?rfc include='reference.RFC.8915'?>

      <?rfc include='reference.RFC.8633'?>

      <!---->
    </references>
  </back>
</rfc>
